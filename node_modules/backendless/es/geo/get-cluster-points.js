"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClusterPoints = getClusterPoints;

var _async = _interopRequireDefault(require("../request/async"));

var _cluster = _interopRequireDefault(require("./cluster"));

var _point = _interopRequireDefault(require("./point"));

var _query = _interopRequireDefault(require("./query"));

var _findHelpers = _interopRequireDefault(require("./find-helpers"));

function getClusterPoints(geoObject, asyncHandler) {
  if (!geoObject.objectId || !(geoObject instanceof _cluster["default"])) {
    throw new Error('Method argument must be a valid instance of GeoCluster persisted on the server');
  }

  if (!(geoObject.geoQuery instanceof _query["default"])) {
    throw new Error('Invalid GeoCluster object. ' + 'Make sure to obtain an instance of GeoCluster using the Backendless.Geo.find API');
  }

  var url = this.app.urls.geoClusterPoints(geoObject.objectId) + '?';
  var geoQuery = geoObject.geoQuery;

  for (var prop in geoQuery) {
    if (geoQuery.hasOwnProperty(prop) && _findHelpers["default"].hasOwnProperty(prop) && geoQuery[prop] != null) {
      url += '&' + _findHelpers["default"][prop](geoQuery[prop]);
    }
  }

  var responderOverride = function responderOverride(asyncHandler) {
    var success = function success(geoCollection) {
      for (var i = 0; i < geoCollection.length; i++) {
        geoCollection[i] = new _point["default"](geoCollection[i]);
      }

      asyncHandler.success(geoCollection);
    };

    var error = function error(data) {
      return asyncHandler.fault(data);
    };

    return new _async["default"](success, error);
  };

  asyncHandler = responderOverride(asyncHandler);
  return this.app.request.get({
    url: url,
    isAsync: !!asyncHandler,
    asyncHandler: asyncHandler
  });
}