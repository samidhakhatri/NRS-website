"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _constants = require("./constants");

var numberRegexp = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/; // Matches sequences like '100 100' or '100 100 100'.

var tuples = new RegExp('^' + numberRegexp.source + '(\\s' + numberRegexp.source + '){1,}');

var wktToGeoJSON = function wktToGeoJSON(wktString) {
  var i = 0;

  var matches = function matches(re) {
    var match = wktString.substring(i).match(re);

    if (!match) {
      return null;
    } else {
      i += match[0].length;
      return match[0];
    }
  };

  var white = function white() {
    return matches(/^\s*/);
  };

  var getMultiCoordinates = function getMultiCoordinates() {
    white();
    var depth = 0;
    var rings = [];
    var stack = [rings];
    var pointer = rings;
    var elem;

    while (elem = matches(/^(\()/) || matches(/^(\))/) || matches(/^(,)/) || matches(tuples)) {
      if (elem === '(') {
        stack.push(pointer);
        pointer = [];
        stack[stack.length - 1].push(pointer);
        depth++;
      } else if (elem === ')') {
        // For the case: Polygon(), ...
        if (pointer.length === 0) {
          return null;
        }

        pointer = stack.pop(); // the stack was empty, wkt string was malformed

        if (!pointer) {
          return null;
        }

        depth--;

        if (depth === 0) {
          break;
        }
      } else if (elem === ',') {
        pointer = [];
        stack[stack.length - 1].push(pointer);
      } else if (!elem.split(/\s/g).some(isNaN)) {
        Array.prototype.push.apply(pointer, elem.split(/\s/g).map(parseFloat));
      } else {
        return null;
      }

      white();
    }

    if (depth !== 0) {
      return null;
    }

    return rings;
  };

  var getCoordinates = function getCoordinates() {
    var list = [];
    var item;
    var pt;

    while (pt = matches(tuples) || matches(/^(,)/)) {
      if (pt === ',') {
        list.push(item);
        item = [];
      } else if (!pt.split(/\s/g).some(isNaN)) {
        if (!item) {
          item = [];
        }

        item = [].concat((0, _toConsumableArray2["default"])(item), (0, _toConsumableArray2["default"])(pt.split(/\s/g).map(parseFloat)));
      }

      white();
    }

    if (item) {
      list.push(item);
    } else {
      return null;
    }

    return list.length ? list : null;
  };

  var point = function point() {
    if (!matches(/^(point(\sz)?)/i)) {
      return null;
    }

    white();

    if (!matches(/^(\()/)) {
      return null;
    }

    white();
    var coordinates = getCoordinates();

    if (!coordinates) {
      return null;
    }

    if (!matches(/^(\))/)) {
      return null;
    }

    return {
      type: _constants.GeoTypes.POINT,
      coordinates: coordinates[0]
    };
  };

  var linestring = function linestring() {
    if (!matches(/^(linestring(\sz)?)/i)) {
      return null;
    }

    white();

    if (!matches(/^(\()/)) {
      return null;
    }

    var coordinates = getCoordinates();

    if (!coordinates) {
      return null;
    }

    if (!matches(/^(\))/)) {
      return null;
    }

    return {
      type: _constants.GeoTypes.LINE_STRING,
      coordinates: coordinates
    };
  };

  var polygon = function polygon() {
    if (!matches(/^(polygon(\sz)?)/i)) {
      return null;
    }

    white();
    var coordinates = getMultiCoordinates();

    if (!coordinates) {
      return null;
    }

    return {
      type: _constants.GeoTypes.POLYGON,
      coordinates: coordinates
    };
  };

  return point() || linestring() || polygon();
};

var _default = wktToGeoJSON;
exports["default"] = _default;