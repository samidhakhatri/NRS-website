"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadRelations = loadRelations;
exports.setRelation = setRelation;
exports.addRelation = addRelation;
exports.deleteRelation = deleteRelation;

var _utils = _interopRequireDefault(require("../../utils"));

var _loadRelationsQueryBuilder = _interopRequireDefault(require("../load-relations-query-builder"));

var _extractQueryOptions = require("./extract-query-options");

//TODO: refactor me
function collectRelationObject(parent, columnName, children) {
  var relation = {
    columnName: columnName
  };

  if (_utils["default"].isString(parent)) {
    relation.parentId = parent;
  } else if (_utils["default"].isObject(parent)) {
    relation.parentId = parent.objectId;
  }

  if (_utils["default"].isString(children)) {
    relation.whereClause = children;
  } else if (_utils["default"].isArray(children)) {
    relation.childrenIds = children.map(function (child) {
      return _utils["default"].isObject(child) ? child.objectId : child;
    });
  }

  return relation;
}

function manageRelation(method, url, relation, asyncHandler) {
  var responder = asyncHandler;

  if (!relation.parentId) {
    throw new Error('Invalid value for the "parent" argument. ' + 'The argument is required and must contain only string or object values.');
  }

  if (!relation.columnName) {
    throw new Error('Invalid value for the "columnName" argument. ' + 'The argument is required and must contain only string values.');
  }

  if (!relation.whereClause && !relation.childrenIds) {
    throw new Error('Invalid value for the third argument. ' + 'The argument is required and must contain string values if it sets whereClause ' + 'or array if it sets childObjects.');
  }

  return this.app.request.send({
    method: method,
    url: url,
    isAsync: !!responder,
    asyncHandler: responder,
    data: relation.childrenIds
  });
}

function buildRelationUrl(className, relation) {
  var url = this.app.urls.dataTableObjectRelation(className, relation.parentId, relation.columnName);

  if (relation.whereClause) {
    url += '?' + _utils["default"].toQueryParams({
      whereClause: relation.whereClause
    });
  }

  return url;
}

function loadRelations(parentObjectId, queryBuilder, asyncHandler) {
  var _this = this;

  if (!parentObjectId || !_utils["default"].isString(parentObjectId)) {
    throw new Error('The parentObjectId is required argument and must be a nonempty string');
  }

  if (!(queryBuilder instanceof _loadRelationsQueryBuilder["default"])) {
    throw new Error('Invalid queryBuilder object.' + 'The queryBuilder is required and must be instance of the Backendless.LoadRelationsQueryBuilder');
  }

  var dataQuery = queryBuilder.build();
  var relationName = dataQuery.options && dataQuery.options.relationName;

  if (!relationName || !_utils["default"].isString(relationName)) {
    throw new Error('The options relationName is required and must contain string value');
  }

  var options;
  var query = [];

  if (dataQuery.options) {
    options = (0, _extractQueryOptions.extractQueryOptions)(dataQuery.options);
  }

  if (options) {
    query.push(options);
  }

  if (dataQuery.condition) {
    query.push('where=' + encodeURIComponent(dataQuery.condition));
  }

  if (dataQuery.havingClause) {
    query.push('having=' + encodeURIComponent(dataQuery.havingClause));
  }

  if (dataQuery.properties && dataQuery.properties.length) {
    query.push('props=' + _utils["default"].encodeArrayToUriComponent(dataQuery.properties));
  }

  var url = this.app.urls.dataTableObjectRelation(this.className, parentObjectId, relationName);

  if (asyncHandler) {
    asyncHandler = _utils["default"].wrapAsync(asyncHandler, function (resp) {
      return _this.parseFindResponse(resp, dataQuery.relationModel);
    });
  }

  if (query.length) {
    url += '?' + query.join('&');
  }

  var result = this.app.request.get({
    url: url,
    isAsync: !!asyncHandler,
    asyncHandler: asyncHandler
  });

  if (asyncHandler) {
    return result;
  }

  return this.parseFindResponse(result, dataQuery.relationModel);
}

function setRelation(parent, columnName, children, asyncHandler) {
  var relation = collectRelationObject(parent, columnName, children);
  var url = buildRelationUrl.call(this, this.className, relation);
  return manageRelation.call(this, 'POST', url, relation, asyncHandler);
}

function addRelation(parent, columnName, children, asyncHandler) {
  var relation = collectRelationObject(parent, columnName, children);
  var url = buildRelationUrl.call(this, this.className, relation);
  return manageRelation.call(this, 'PUT', url, relation, asyncHandler);
}

function deleteRelation(parent, columnName, children, asyncHandler) {
  var relation = collectRelationObject(parent, columnName, children);
  var url = buildRelationUrl.call(this, this.className, relation);
  return manageRelation.call(this, 'DELETE', url, relation, asyncHandler);
}