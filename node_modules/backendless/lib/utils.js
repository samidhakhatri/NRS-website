"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _async = _interopRequireDefault(require("./request/async"));

var Utils = {
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isArray: Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === 'Array';
  },
  isString: function isString(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === 'String';
  },
  isNumber: function isNumber(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === 'Number';
  },
  isFunction: function isFunction(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === 'Function';
  },
  isBoolean: function isBoolean(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === 'Boolean';
  },
  isDate: function isDate(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1) === 'Date';
  },
  isBrowser: isBrowser(),
  isLocalStorageSupported: isLocalStorageSupported(),
  castArray: function castArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === 'undefined') {
      return [];
    }

    return [value];
  },
  isCustomClassInstance: function isCustomClassInstance(item) {
    if (!item || (0, _typeof2["default"])(item) !== 'object' || Array.isArray(item)) {
      return false;
    }

    return item.constructor !== Object;
  },
  isEmpty: function isEmpty(obj) {
    if (obj === null || obj === undefined) {
      return true;
    }

    if (Utils.isArray(obj) || Utils.isString(obj)) {
      return obj.length === 0;
    }

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] !== undefined && obj[key] !== null) {
        return false;
      }
    }

    return true;
  },
  toQueryParams: function toQueryParams(params) {
    params = params || {};
    var result = [];

    for (var key in params) {
      if (params.hasOwnProperty(key)) {
        result.push(key + '=' + encodeURIComponent(params[key]));
      }
    }

    return result.join('&');
  },
  tryParseJSON: function tryParseJSON(s) {
    try {
      return typeof s === 'string' ? JSON.parse(s) : s;
    } catch (e) {
      return s;
    }
  },
  getClassName: function getClassName(obj) {
    if (obj && obj.className) {
      return obj.className;
    }

    if (typeof obj === 'function') {
      if (obj.name) {
        return obj.name;
      }
    }

    if (obj && (0, _typeof2["default"])(obj) === 'object' && !Array.isArray(obj)) {
      if (obj.___class) {
        return obj.___class;
      }

      if (obj.constructor !== Object) {
        return Utils.getClassName(obj.constructor);
      }
    }

    return null;
  },
  encodeArrayToUriComponent: function encodeArrayToUriComponent(arr) {
    return arr.map(function (item) {
      return encodeURIComponent(item);
    }).join(',');
  },
  deepExtend: function deepExtend(destination, source) {
    var classToTableMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    //TODO: refactor it
    for (var property in source) {
      if (source[property] !== undefined && source.hasOwnProperty(property)) {
        destination[property] = destination[property] || {};
        destination[property] = classWrapper(source[property], classToTableMap);

        if (destination[property] && destination[property].hasOwnProperty(property) && destination[property][property] && destination[property][property].hasOwnProperty('__originSubID')) {
          destination[property][property] = classWrapper(destination[property], classToTableMap);
        }
      }
    }

    return destination;
  },
  extractResponder: function extractResponder(args) {
    for (var i = 0; i < args.length; i++) {
      if (args[i] instanceof _async["default"]) {
        return args[i];
      }
    }
  },
  wrapAsync: function wrapAsync(asyncHandler, parser, context) {
    //TODO: should we remove it?
    if (asyncHandler instanceof _async["default"] && !parser) {
      return asyncHandler;
    }

    var success = function success(data) {
      if (parser) {
        data = parser.call(context, data);
      }

      asyncHandler.success(data);
    };

    var error = function error(data) {
      asyncHandler.fault(data);
    };

    return new _async["default"](success, error);
  },
  promisified: function promisified(method) {
    return function () {
      Utils.checkPromiseSupport();
      var args = [].slice.call(arguments);
      var context = this;
      var fn = typeof method === 'function' ? method : context[method];
      return new Promise(function (resolve, reject) {
        args.push(new _async["default"](resolve, reject, context));
        fn.apply(context, args);
      });
    };
  },
  "synchronized": function synchronized(method) {
    return function () {
      // eslint-disable-next-line no-console
      console.warn('Using of sync methods is an outdated approach. Please use async methods.');
      var context = this;
      var fn = typeof method === 'function' ? method : context[method];
      return fn.apply(context, arguments);
    };
  },
  checkPromiseSupport: function checkPromiseSupport() {
    if (typeof Promise === 'undefined') {
      throw new Error('This browser doesn\'t support Promise API. Please use polyfill.\n' + 'More info is in the Backendless JS-SDK docs: https://backendless.com/docs/js/doc.html#sync-and-async-calls');
    }
  },
  mirrorKeys: function mirrorKeys(obj) {
    var mirroredObject = {};

    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        mirroredObject[key] = key;
      }
    }

    return mirroredObject;
  },
  uuid: function uuid() {
    var chr4 = function chr4() {
      return Math.random().toString(16).slice(-4).toUpperCase();
    };

    var chr8 = function chr8() {
      return "".concat(chr4()).concat(chr4());
    };

    var chr12 = function chr12() {
      return "".concat(chr4()).concat(chr4()).concat(chr4());
    };

    return "".concat(chr8(), "-").concat(chr4(), "-").concat(chr4(), "-").concat(chr4(), "-").concat(chr12());
  }
};

function isBrowser() {
  return (typeof self === "undefined" ? "undefined" : (0, _typeof2["default"])(self)) === 'object' && self.self === self && (typeof window === "undefined" ? "undefined" : (0, _typeof2["default"])(window)) === 'object' && window === self;
}

function isLocalStorageSupported() {
  try {
    if (isBrowser() && window.localStorage) {
      localStorage.setItem('localStorageTest', true);
      localStorage.removeItem('localStorageTest');
      return true;
    }
  } catch (e) {}

  return false;
}

function classWrapper(obj, classToTableMap) {
  //TODO: refactor it
  var wrapper = function wrapper(obj) {
    var wrapperName = null;
    var Wrapper = null;

    for (var property in obj) {
      if (obj.hasOwnProperty(property)) {
        if (property === '___class') {
          wrapperName = obj[property];
          break;
        }
      }
    }

    if (wrapperName) {
      try {
        Wrapper = classToTableMap[wrapperName] || eval(wrapperName);
        obj = Utils.deepExtend(new Wrapper(), obj, classToTableMap);
      } catch (e) {}
    }

    return obj;
  };

  if (obj && (0, _typeof2["default"])(obj) === 'object') {
    if (Array.isArray(obj)) {
      for (var i = obj.length; i--;) {
        obj[i] = wrapper(obj[i]);
      }
    } else {
      obj = wrapper(obj);
    }
  }

  return obj;
}

var _default = Utils;
exports["default"] = _default;