"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseFindResponse = parseFindResponse;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _utils = _interopRequireDefault(require("../../utils"));

var _geoConstructor = _interopRequireDefault(require("../geo/geo-constructor"));

var GEO_CLASSES = ['com.backendless.persistence.Polygon', 'com.backendless.persistence.LineString', 'com.backendless.persistence.Point', 'com.backendless.persistence.Geometry'];

function parseCircularDependencies(obj) {
  var result = new obj.constructor();
  var subIds = {};
  var postAssign = [];
  var iteratedItems = [];

  function ensureCircularDep(source, target, prop) {
    if (subIds[source[prop].__originSubID]) {
      target[prop] = subIds[source[prop].__originSubID];
    } else {
      postAssign.push([target, prop, source[prop].__originSubID]);
    }
  }

  function processModel(source, target, prop) {
    if (source[prop].__subID && subIds[source[prop].__subID]) {
      target[prop] = subIds[source[prop].__subID];
    } else {
      target[prop] = new source[prop].constructor();
    }

    if (source[prop].__subID) {
      subIds[source[prop].__subID] = target[prop];
      delete source[prop].__subID;
    }
  }

  function buildCircularDeps(source, target) {
    if (!iteratedItems.includes(source)) {
      iteratedItems.push(source);

      for (var prop in source) {
        if (source.hasOwnProperty(prop) && (!Array.isArray(target[prop]) || !target[prop])) {
          if (Array.isArray(source[prop])) {
            buildCircularDeps(source[prop], target[prop] = []);
          } else if (source[prop] && (0, _typeof2["default"])(source[prop]) === 'object') {
            if (GEO_CLASSES.includes(source[prop].___class)) {
              target[prop] = (0, _geoConstructor["default"])(source[prop]);
            } else if (source[prop].__originSubID) {
              ensureCircularDep(source, target, prop);
            } else {
              processModel(source, target, prop);
              buildCircularDeps(source[prop], target[prop]);
            }
          } else {
            target[prop] = source[prop];
          }
        }
      }
    }
  }

  buildCircularDeps(obj, result);
  postAssign.forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 3),
        target = _ref2[0],
        prop = _ref2[1],
        __originSubID = _ref2[2];

    return target[prop] = subIds[__originSubID];
  });
  return result;
}

function parseFindResponse(response, Model, classToTableMap) {
  var sanitizeResponseItem = function sanitizeResponseItem(record) {
    Model = typeof Model === 'function' ? Model : classToTableMap[record.___class];
    return _utils["default"].deepExtend(Model ? new Model() : {}, record, classToTableMap);
  };

  var result = Array.isArray(response) ? response.map(sanitizeResponseItem) : sanitizeResponseItem(response);
  return parseCircularDependencies(result);
}